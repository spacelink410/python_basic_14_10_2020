"""Свои функции, используемые в домашней работе"""

# Основные импорты
import random


# дополнительные импорты, используемые для проверок своих функций
# import math


def random_range_int(min_range=0, max_range=100, size_range=20):
    """Функция генерирует случайные целочисленные значения в выбранном диапазоне

    :param min_range: нижняя граница генерирумого диапазона. По умолчанию 0.
    :param max_range: верхняя граница генерирумого диапазона. По умолчанию 100.
    :param size_range: размер генерируемого списка.
    :return: объект генератор, содержащий случайное число.
    """

    if max_range > min_range and size_range > 0:
        while size_range:
            yield random.randint(min_range, max_range)
            size_range -= 1


def my_range(start: int = 0, stop: int = 10, step: int = 1):
    """Функция возвращает элементы последовательности в указанном дапазоне с опредеденным шагом

    :param start: начало диапазона. По умолчанию 0.
    :param stop: конец диапазона. По умолчанию 10.
    :param step: шаг генерации диапазона. По умолчанию 1.
    :return: объект генератор, возвращающий последовательные значения
    """

    if stop > start and step != 0:
        while start < stop:
            yield start
            start += step


def my_reduce(func, iter_obj: list):
    """Применяет функцию двух аргументов накопительно к значениям последовательности,
    сводя ее к одному значению

    :param func: функция применчемая к элементам
    :param iter_obj: итерируемы объект
    :return: последний и единственный элемент последовательности измененный в результате функции func
    """

    while len(iter_obj) > 1:
        iter_obj.insert(0, func(iter_obj.pop(0), iter_obj.pop(0)))
    return iter_obj[0]


def fact(numb: int):
    """Реализует последовательность факториалов чисел от 1 до того числа, которое поступило на вход.

    :param numb: натуральное число от которого планируется считать факториал
    :return: возвращает объект генератор факториал для каждого числа от 1 до numb

    """

    buff_list: list = list(my_range(1, numb + 1))

    # используя встроенную функцию факториала
    # while numb > 0:
    #     yield math.factorial(buff_list.pop(0))
    #     numb -= 1

    """
    Используя свой велосипед.
    Был большой соблазн использовать свою функцию my_reduce, но не захотелось портить ее условиями
    отдавать генератор в котором в итоге будет список значений или отдавать конкретное число, 
    как для обычной функции reduce, учитывая, что нам еще требуется выводить факториал каждого числа от
    1 до n. В общем не хотелось костылить... Или было лень и не додумал.
    
    """

    i: int = 0
    while i < numb:
        if buff_list[0] == 1 and i == 0:
            yield 1
        else:
            buff_list.insert(0, buff_list.pop(0) * buff_list.pop(0))
            yield buff_list[0]
        i += 1
